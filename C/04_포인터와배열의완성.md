# 04 포인터와 배열의 완성
## 16. 다차원 배열
### 16.1 다차원 배열의 이해와 활용
- 다차원 배열은 2차원 이상의 배열을 의미한다.
#### 16.1.1 2차원, 3차원 배열? OK! 4차원, 5차원 배열? NO!
- 2차원 배열은 평면구조의 배열, 3차원 배열은 직육면체구조의 배열이다.
- C언어는 4차원 이상의 배열선언을 문법적으로 허용하긴 하지만, 불필요하기도 하고 논리적으로 이해하기도 어려운 형태의 배열이다.
- 1,2,3차원 배열의 선언형태
  ```
    int arrOneDim[10];          // 길이가 10인 1차원 int형 배열
    int arrTwoDim[5][5];        // 가로, 세로의 길이가 각각 5인 2차원 int형 배열
    int arrThreeDim[3][3][3];   // 가로, 세로, 높이의 길이가 각각 3인 3차원 int형 배열
  ```
#### 16.1.2 다차원 배열을 대표하는 2차원 배열의 선언
```
  int arr1[3][4];   
  int arr2[7][9];   
```
이와 같이 2차원 배열의 선언형태는 `TYPE arr[행][열];`
- sizeof 연산자의 피연산자로 배열의 이름이 오면, 배열의 크기가 바이트 단위로 계산되어 반환되었듯이 2차원 배열의 크기도 계산 가능
```
  printf("세로3, 가로4: %d \n", sizeof(arr1));      // 48
  printf("세로7, 가로9: %d \n", sizeof(arr2));      // 252
```
#### 16.1.3 2차원 배열요소의 접근
```
  arr[N-1][M-1] = 20;           // 행 N, 열 M의 위치에 정수 20을 저장
  printf("%d", arr[N-1][M-1]);  // 행 N, 열 M의 위치에 저장된 값 출력
```
#### 16.1.4 2차원 배열의 메모리상 할당의 형태
- 2차원 배열이라 해도 메모리상에는 1차원의 형태로 존재한다.
  ```
    int arr[3][2];
    int i, j;
    for (i = 0; i < 3; i++) {
      for (j = 0; j < 2; j++) {
        printf("%p \n", &arr[i][j]);
      }
    }
  ```
  + 실행결과 => int형 변수의 크기인 4바이트 만큼 차이가 난다.
  ```
    0x7fff5fbff750
    0x7fff5fbff754
    0x7fff5fbff758
    0x7fff5fbff75c
    0x7fff5fbff760
    0x7fff5fbff764
  ```
#### 16.1.5 2차원 배열 선언과 동시에 초기화하기
1.
  ```
    int arr[3][3] = {
      {1, 2, 3},
      {4, 5, 6},
      {7, 8, 9}
    };
  ```
  행 단위로 초기화할 값들을 별도의 중괄호로 명시해야 한다.

2.
  ```
    int arr[3][3] = {
      {1},
      {4, 5},
      {7, 8, 9}
    };
  ```
  모든 배열요소를 초기화해야 하는 것은 아니다. 빈 공간은 0으로 초기화 된다. 따라서,
  ```
    int arr[3][3] = {
      {1, 0, 0},
      {4, 5, 0},
      {7, 8, 9}
    };                    // 이렇게 선언하는 것과 동일하다.
  ```

3.
  ```
    int arr[3][3] = {
      1, 2, 3,
      4, 5, 6,
      7
    };
  ```
  + 이렇게 하나의 중괄호 안에 초기화할 값을 순서대로 나열할 수도 있다.
  + `int arr[3][3] = {1, 2, 3, 4, 5, 6, 7};`
  + 부족한 영역은 0으로 채워진다.
  + `int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 0, 0};`과 동일한 결과
#### 16.1.6 배열의 크기를 알려주지 않고 초기화하기
- 1차원 배열선언 시, 배열의 크기를 명시하지 않아도 선언이 가능했다.
- 2차원 배열의 경우에도 초기화 리스트가 존재한다면, 길이를 명시하지 않아도 되지만 **제약사항** 이 존재한다.
  + `int arr[][] = {1, 2, 3, 4, 5, 6, 7, 8};` 다음과 같은 경우 행과 열의 길이를 어떻게 결정하겠냐?
  + 행과 열의 길이를 모두 예측하는 것은 불가능하니 한 쪽을 명시해주어야 하는데 이 때, **행의 길이만 생략이 가능** 하다.
  ```
    int arr1[][4] = {1, 2, 3, 4, 5, 6, 7, 8};
    int arr2[][2] = {1, 2, 3, 4, 5, 6, 7, 8};
  ```
### 16.2 3차원 배열
- 3차원 배열은 흔히 사용되는 배열이 아니다. 매우 제한적인 상황에서 사용된다.
- 3차원 배열은 가로와 세로로 이뤄진 2차원 배열에 높이의 개념이 추가되어 있다.
  ```
    int arr1[2][3][4];      // 높이 2, 세로 3, 가로 4인 int형 3차원 배열
    printf("높이2, 세로3, 가로4 int형 배열: %d \n", sizeof(arr1));   // 2 * 3 * 4 * sizeof(int) = 96
  ```
#### 16.2.1 3차원 배열의 선언과 접근
- ex. 어느 고등학교 3학년 전체 학생의 국어와 수학점수를 반별로 구분하여 저장한 예. 각 반별 학생수는 3명, 학급의 수도 3개
  ```
    int record[3][3][2] = {
      {70, 80},               // A 학급 학생 1의 성적
      {94, 90},               //       학생 2
      {70, 85}                //       학생 3
    },
    {
      {83, 90},               // B 학급 학생 1의 성적
      {95, 60},               //       학생 2
      {90, 82}                //       학생 3
    },
    {
      {98, 89},               // C 학급 학생 1의 성적
      {99, 64},               //       학생 2
      {91, 87}                //       학생 3
    };
  ```
  3차원 배열은 여러 개의 2차원 배열이 모여있는 형태

## 17. 포인터의 포인터
### 17.1 포인터의 포인터에 대한 이해
- 포인터의 포인터는 포인터 변수를 가리키는 또 다른 포인터 변수를 뜻함. '이중 포인터' 혹은 '더블 포인터'라 불린다.
- `int ** dptr;` => int형 이중 포인터
#### 17.1.1 포인터 변수를 가리키는 이중 포인터 변수 (더블 포인터 변수)
- **포인터 변수는 종류에 상관없이 무조건 주소 값을 저장하는 변수** 이다. 다만 포인터 변수가 가리키는 대상의 차이만 있을뿐.
  ```
    double num = 3.14;
    double* ptr = &num;   // 변수 num의 주소 값 저장
  ```
  + 변수 num과 포인터 변수 ptr의 공통점과 차이점
    - **공통점**: 둘 다 변수이다. => 값의 저장이 가능하다.
    - **차이점**: 저장하는 값의 종류(유형)가 다르다.
    - 이렇듯 ptr도 메모리 공간에 할당이 되는 변수이다. 따라서 이를 대상으로도 & 연산이 가능.
    - 이 때 반환되는 주소 값은 'double형 더블 포인터 변수'에 저장이 가능하다.
      + `double ** dptr = &ptr;`
      + 즉, `dptr` ----> `ptr` ----> `num`
      ```
        *dptr = ...;      // *dptr은 포인터 변수 ptr을 의미함
        *(*dptr) = ...;   // *(*dptr)은 변수 num을 의미함 (== **dptr)
      ```
  ```
    double num = 3.14;
    double * ptr = &num;
    double ** dptr = &ptr;
    double * ptr2;

    printf("%9p %9p \n", ptr, *dptr);
    printf("%9g %9g \n", num, **dptr);
    ptr2 = *dptr;     // ptr2 = ptr과 동일
    *ptr2 = 10.99;
    printf("%9g %9g \n", num, **dptr);
  ```
  + 여기서 변수 num에 접근하는 방법은 총 4가지가 있음을 알 수 있다.
  ```
    **dptr = 10.1;    // 변수 num에 10.1이 저장됨
    *ptr = 20.2;      // 변수 num에 20.2가 저장됨
    *ptr2 = 30.3;     // 변수 num에 30.3이 저장됨
    num = 40.4;       // 변수 num에 접근하는 가장 기본적인 방법
  ```
#### 17.1.2 포인터 변수 대상의 Call-by-reference
```
  void SwapChange(int * ptr1, int * ptr2) {
    int temp = *ptr1;
    *ptr1 = *ptr2;
    *ptr2 = temp;
  }
```
- 이전에 위와 같이 두 변수의 저장된 값을 변경했었다. ===> 두 싱글 포인터 변수에 저장된 값을 바꾸는 함수로 수정해보자.
- 즉, 포인터 변수의 참조관계를 바꿔주는 함수를 정의하려는 것
  ```
    void SwapIntPtr(int *p1, int *p2) {
      int * temp = p1;
      p1 = p2;
      p2 = temp;
    }

    int main(void) {
      int num1 = 10, num2 = 20;
      int * ptr1, * ptr2;
      ptr1 = &num1, ptr2 = &num2;
      printf("*ptr1, *ptr2: %d %d \n", *ptr1, *ptr2);       // 10 20

      SwapIntPtr(ptr1, ptr2);
      printf("*ptr1, *ptr2: %d %d \n", *ptr1, *ptr2);       // 10 20
      return 0;
    }
  ```
  + 위의 경우 SwapIntPtr 함수를 호출한 이후에도 값이 서로 바뀌지 않는다.
  + ptr1과 ptr2는 매개변수로 값을 전달만 해준것이기 때문이다. 그렇다면 어떻게?
  + 이를 위해서는 함수 내에서 포인터 변수 ptr1과 ptr2에 **직접 접근** 이 가능해야 한다.
    ```
      void SwapIntPtr(int **dp1, int **dp2) {
        int *temp = *dp1;
        *dp1 = *dp2;
        *dp2 = temp;
      }

      int main(void) {
        int num1 = 10, num2 = 20;
        int *ptr1, *ptr2;
        ptr1 = &num1, ptr2 = &num2;
        printf("*ptr1, *ptr2: %d %d \n", *ptr1, *ptr2);     // 10 20

        SwapIntPtr(&ptr1, &ptr2);
        printf("*ptr1, *ptr2: %d %d \n", *ptr1, *ptr2);     // 20 10
        return 0;
      }
    ```
#### 17.1.3 포인터 배열과 포인터 배열의 포인터 형
```
  int * arr1[20];       // 길이가 20인 int형 포인터 배열 arr1
  double * arr2[30];    // 길이가 30인 double형 포인터 배열 arr2
```
- 이 int형 포인터 배열의 이름 arr1과 double형 포인터 배열의 이름 arr2의 포인터 형은 어떻게 될까?
  + 이 역시 1차원 배열이기 때문에 배열이름이 가리키는 첫 번째 요소의 자료형에 따라서 포인터 형이 결정된다.
  + 즉, arr1이 가리키는 첫 번째 요소는 int형 싱글 포인터이니 배열이름 arr1은 int형 더블 포인터가 된다.
  + arr2가 가리키는 첫 번째 요소는 double형 싱글 포인터이니 배열이름 arr2는 double형 더블 포인터가 된다.
  ```
    int num1 = 10, num2 = 20, num3 = 30;
    int *ptr1 = &num1, *ptr2 = &num2, *ptr3 = &num3;

    int * ptrArr[] = {ptr1, ptr2, ptr3};
    int **dptr = ptrArr;

    printf("%d %d %d \n", *(ptrArr[0]), *(ptrArr[1]), *(ptrArr[2]));    // 10 20 30
    printf("%d %d %d \n", *(dptr[0]), *(dptr[1]), *(dptr[2]));          // 10 20 30
  ```
  + dptr과 ptrArr의 포인터 형이 일치함을 알 수 있다.

### 17.2 다중 포인터 변수와 포인터의 필요성
- **다중 포인터 변수**: 포인터 변수의 선언에 있어서 \* 연산자가 둘 이상 사용되어 선언되는 포인터 변수를 가리킴
- 포인터 변수 선언 시 * 연산자는 얼마든지 추가될 수 있다.
#### 17.2.1 이중 포인터를 가리키는 삼중 포인터
- `int ***tptr;` ===> tptr은 삼중 포인터 변수
- 삼중 포인터 변수는 이중 포인터 변수를 가리키는 용도로, 이중 포인터 변수의 주소 값을 저장하는 용도로 사용된다.
  ```
    int num = 100;
    int *ptr = &num;
    int **dptr = &ptr;
    int ***tptr = &dptr;

    printf("%d %d \n", **dptr, ***tptr);    // 100 100
  ```
  삼중 포인터가 사용되는 예는 그리 많지 않다.
#### 17.2.2 포인터의 필요성은 어디서 찾아야 하는가?
- 자료구조를 공부하게 되면 포인터의 필요성을 보다 확실히 느끼고 알 수 있게 된다.
- 자료구조는 데이터의 효율적인 표현 및 저장방법을 공부하는 학문이기 때문에, 데이터의 다양한 표현 및 저장의 중심에 '포인터'가 존재함.
- **포인터는 함수 내에서 함수 외부에 선언된 변수에 접근하는 방법을 제시해준다.**

#### ex. 이중 포인터 변수의 활용
- 다음과 같이 두 개의 int형 포인터 변수와 길이가 5인 int형 배열을 선언한다.
  ```
    int * maxPtr;
    int * minPtr;
    int arr[5];
  ```
- 그리고 MaxAndMin이란 이름의 함수를 정의하고 이를 호출하면서 위의 배열과 두 포인터 변수에 대한 정보를 전달하자.
- 함수의 호출이 완료되면 포인터 변수 maxPtr에는 가장 큰 값이 저장된 배열요소의 주소 값이,
- minPtr에는 가장 작은 값이 저장된 배열요소의 주소 값이 저장되어야 한다.

  ```
    #include <stdio.h>

    void MaxAndMin(int* arr, int size, int** mxPtr, int** mnPtr) {
      int* max;
      int* min;
      max = min = arr;
      int i;

      for (i = 0; i < size; i++) {
        if (*max < arr[i]) {
          max = &arr[i];
        }
        if (*min > arr[i]) {
          min = &arr[i];
        }
      }

      *mxPtr = max;
      *mnPtr = min;      
    }

    int main(void) {
      int * maxPtr;
      int * minPtr;
      int arr[5];
      int i;

      for (i = 0; i < 5; i++) {
        printf("정수 입력 %d: ", i+1);
        scanf("%d", &arr[i]);
      }

      MaxAndMin(arr, sizeof(arr)/sizeof(int), &maxPtr, &minPtr);
      printf("최대: %d, 최소: %d \n", *maxPtr, *minPtr);
      return 0;
    }
  ```
