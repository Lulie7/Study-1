# 04 포인터와 배열의 완성
## 16. 다차원 배열
### 16.1 다차원 배열의 이해와 활용
- 다차원 배열은 2차원 이상의 배열을 의미한다.
#### 16.1.1 2차원, 3차원 배열? OK! 4차원, 5차원 배열? NO!
- 2차원 배열은 평면구조의 배열, 3차원 배열은 직육면체구조의 배열이다.
- C언어는 4차원 이상의 배열선언을 문법적으로 허용하긴 하지만, 불필요하기도 하고 논리적으로 이해하기도 어려운 형태의 배열이다.
- 1,2,3차원 배열의 선언형태
  ```
    int arrOneDim[10];          // 길이가 10인 1차원 int형 배열
    int arrTwoDim[5][5];        // 가로, 세로의 길이가 각각 5인 2차원 int형 배열
    int arrThreeDim[3][3][3];   // 가로, 세로, 높이의 길이가 각각 3인 3차원 int형 배열
  ```
#### 16.1.2 다차원 배열을 대표하는 2차원 배열의 선언
```
  int arr1[3][4];   
  int arr2[7][9];   
```
이와 같이 2차원 배열의 선언형태는 `TYPE arr[행][열];`
- sizeof 연산자의 피연산자로 배열의 이름이 오면, 배열의 크기가 바이트 단위로 계산되어 반환되었듯이 2차원 배열의 크기도 계산 가능
```
  printf("세로3, 가로4: %d \n", sizeof(arr1));      // 48
  printf("세로7, 가로9: %d \n", sizeof(arr2));      // 252
```
#### 16.1.3 2차원 배열요소의 접근
```
  arr[N-1][M-1] = 20;           // 행 N, 열 M의 위치에 정수 20을 저장
  printf("%d", arr[N-1][M-1]);  // 행 N, 열 M의 위치에 저장된 값 출력
```
#### 16.1.4 2차원 배열의 메모리상 할당의 형태
- 2차원 배열이라 해도 메모리상에는 1차원의 형태로 존재한다.
  ```
    int arr[3][2];
    int i, j;
    for (i = 0; i < 3; i++) {
      for (j = 0; j < 2; j++) {
        printf("%p \n", &arr[i][j]);
      }
    }
  ```
  + 실행결과 => int형 변수의 크기인 4바이트 만큼 차이가 난다.
  ```
    0x7fff5fbff750
    0x7fff5fbff754
    0x7fff5fbff758
    0x7fff5fbff75c
    0x7fff5fbff760
    0x7fff5fbff764
  ```
#### 16.1.5 2차원 배열 선언과 동시에 초기화하기
1.
  ```
    int arr[3][3] = {
      {1, 2, 3},
      {4, 5, 6},
      {7, 8, 9}
    };
  ```
  행 단위로 초기화할 값들을 별도의 중괄호로 명시해야 한다.

2.
  ```
    int arr[3][3] = {
      {1},
      {4, 5},
      {7, 8, 9}
    };
  ```
  모든 배열요소를 초기화해야 하는 것은 아니다. 빈 공간은 0으로 초기화 된다. 따라서,
  ```
    int arr[3][3] = {
      {1, 0, 0},
      {4, 5, 0},
      {7, 8, 9}
    };                    // 이렇게 선언하는 것과 동일하다.
  ```

3.
  ```
    int arr[3][3] = {
      1, 2, 3,
      4, 5, 6,
      7
    };
  ```
  + 이렇게 하나의 중괄호 안에 초기화할 값을 순서대로 나열할 수도 있다.
  + `int arr[3][3] = {1, 2, 3, 4, 5, 6, 7};`
  + 부족한 영역은 0으로 채워진다.
  + `int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 0, 0};`과 동일한 결과과
#### 16.1.6 배열의 크기를 알려주지 않고 초기화하기
- 1차원 배열선언 시, 배열의 크기를 명시하지 않아도 선언이 가능했다.
- 2차원 배열의 경우에도 초기화 리스트가 존재한다면, 길이를 명시하지 않아도 되지만 **제약사항** 이 존재한다.
  + `int arr[][] = {1, 2, 3, 4, 5, 6, 7, 8};` 다음과 같은 경우 행과 열의 길이를 어떻게 결정하겠냐?
  + 행과 열의 길이를 모두 예측하는 것은 불가능하니 한 쪽을 명시해주어야 하는데 이 때, **행의 길이만 생략이 가능** 하다.
  ```
    int arr1[][4] = {1, 2, 3, 4, 5, 6, 7, 8};
    int arr2[][2] = {1, 2, 3, 4, 5, 6, 7, 8};
  ```
### 16.2 3차원 배열
- 3차원 배열은 흔히 사용되는 배열이 아니다. 매우 제한적인 상황에서 사용된다.
- 3차원 배열은 가로와 세로로 이뤄진 2차원 배열에 높이의 개념이 추가되어 있다.
  ```
    int arr1[2][3][4];      // 높이 2, 세로 3, 가로 4인 int형 3차원 배열
    printf("높이2, 세로3, 가로4 int형 배열: %d \n", sizeof(arr1));   // 2 * 3 * 4 * sizeof(int) = 96
  ```
#### 16.2.1 3차원 배열의 선언과 접근
- ex. 어느 고등학교 3학년 전체 학생의 국어와 수학점수를 반별로 구분하여 저장한 예. 각 반별 학생수는 3명, 학급의 수도 3개
  ```
    int record[3][3][2] = {
      {70, 80},               // A 학급 학생 1의 성적
      {94, 90},               //       학생 2
      {70, 85}                //       학생 3
    },
    {
      {83, 90},               // B 학급 학생 1의 성적
      {95, 60},               //       학생 2
      {90, 82}                //       학생 3
    },
    {
      {98, 89},               // C 학급 학생 1의 성적
      {99, 64},               //       학생 2
      {91, 87}                //       학생 3
    };
  ```
  3차원 배열은 여러 개의 2차원 배열이 모여있는 형태

## 17. 포인터의 포인터
