# 재귀 호출 (Recursion)
## 1. 기본개념
- 재귀적 접근 방법 : 큰 문제를 작은 문제들로 나누는 것으로부터 시작
  + 나누어진 작은 문제들은 모두 같은 타입이어야 한다.
  + ex) 큰 정사각형을 작은 정사각형들로 나누기 (O)
  + ex) 큰 정사각형을 작은 삼각형이나 작은 원들로 나누기 (X)
  + 문제 수준이 간단한 사칙연산 수준이 될 때까지 단순화 시키기
  + **해결하기 힘든 문제를 한 번에 해결하는 것이 아니라 쉽게 풀 수 있는 작은 여러개의 문제들로 쪼개어 해결함 (분할정복)**
- 비선형 자료구조인 트리 혹은 그래프에 있는 모든 노드를 탐색할 때 유용하게 사용

## 2. 재귀 호출의 내부적 구현 (운영체제 내부)
- 운영체제에서는 Stack을 이용하여 재귀 호출을 가능하게 한다.
- `활성 레코드(Activation Record)` : 함수에서 사용되는 모든 지역변수(Local Variable), 전달된 인자(Parameter)를 저장하는 공간
- 운영체제의 스택에 이 활성 레코드를 순서대로 저장한다.
- 운영체제의 관점에서 볼 때, 재귀 호출에 의해 같은 함수가 여러번 호출된다고 하더라도 모두 별개의 함수로 처리된다.
- 그러므로 운영체제의 스택이 지원하는 수준 이상으로 재귀 호출을 반복하게 된다면 스택 메모리 부족 현상이 발생할 수 있다.
- 재귀 호출은 운영체제 상에서 활성화 레코드 사이에 문맥 변경(Context Switch)이 발생하므로 수행시간이 상대적으로 느리다.
- `문맥 변경(Context Switch)`: 새로운 함수의 지역변수와 인자를 적재(Loading). 이를 처리하는 과정에서 시간이 소요됨.
- -> 안정화 시킨 이후에는 재귀 호출을 반복 호출로 방법을 변경하는 것이 더 효율적

## 3. 재귀 호출(Recursion) vs 반복 호출(Iteration)
- `재귀 호출` : 하나의 함수에서 자기 자신을 다시 호출하여 문제 해결
- `반복 호출` : **for**나 **while**을 이용하여 반복적으로 문제 해결
- 재귀 호출의 장단점
  + 장점: 알고리즘의 간결성과 명확성! 반복 호출에 비해 프로그램 읽기가 쉽고, 개발이 간단하다.
  + 단점: 시스템 스택을 사용하므로, 수행시간이 상대적으로 오래 걸리고, 스택 메모리 문제 발생 가능성
- 재귀 호출과 반복 호출은 표현 능력이 같기 때문에 **서로 대체 가능**
- 한 함수 내에서 재귀 호출이 2번 발생하는 경우 반복 호출로 변경할 때 스택을 이용해야 한다.
  + ex) `피보나치 수열` : 재귀 호출 < 반복 호출이 더 효과적
  + ex) `하노이의 탑` : 재귀 호출이 더 효과적 > 반복 호출
